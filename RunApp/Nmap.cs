using PdfSharp.Drawing;
using System.Text.RegularExpressions;
using System.Xml;

namespace RunApp
{
    public static class Nmap
    {
        private static readonly XmlDocument xml = new();

        public static void AddReport(string path)
        {
            if (path != null)
            {
                PDF.champterName = "Nmap";
                PDF.champterColor = XBrushes.Red;
                PDF.NewPage(true);

                xml.Load(path);
                WriteRunInfo();
                WritePorts();
                WriteOS();
                WritePortsOS();
            }
        }

        private static void WriteRunInfo()
        {
            string version = GetAttributeValue("nmaprun", "version");
            string args = GetAttributeValue("nmaprun", "args");
            string elapsed = GetAttributeValue("runstats/finished", "elapsed");
            string exit = GetAttributeValue("runstats/finished", "exit");

            XBrush color;
            if (exit == "success") { color = XBrushes.Green; }
            else { color = XBrushes.Red; }

            PDF.WriteTitle("Nmap: ");
            PDF.WriteLine("Version: ", true, PDF.boldFont);
            PDF.Write(version);
            args = args.Replace("\\\\", "\\");
            args = ParseArgs(args);
            PDF.WriteLine("Args: ", true, PDF.boldFont);
            PDF.WriteLine(args, false, PDF.normalFont, XBrushes.Black, 15);
            PDF.WriteLine("Elapsed: ", true, PDF.boldFont);
            PDF.Write($"{elapsed} s");
            PDF.WriteLine("Exit: ", true, PDF.boldFont);
            PDF.Write(exit, false, PDF.normalFont, color);
        }

        private static string ParseArgs(string args)
        {
            // [^\"]+ : one or more characters that are not a quotation mark
            string pattern = "\"([^\"]+)\"\\s*(.*)";
            Match match = Regex.Match(args, pattern);
            if (match.Success)
            {
                string path = match.Groups[1].Value;
                args = $"nmap {match.Groups[2].Value}";
                PDF.WriteLine("Path: ", true, PDF.boldFont);
                PDF.Write(path);
            }
            return args;
        }

        private static void WritePorts()
        {
            XmlNodeList portNodes = xml.GetElementsByTagName("port");
            XBrush stateColor;

            if (portNodes.Count > 0)
            {
                PDF.WriteTitle("Ports: ");

                foreach (XmlNode node in portNodes)
                {
                    string protocol = GetAttributeValue(node, "protocol");
                    string portid = GetAttributeValue(node, "portid");

                    XmlNode? stateNode = node.SelectSingleNode("state");
                    string state = stateNode != null ? GetAttributeValue(stateNode, "state") : "none";

                    XmlNode? serviceNode = node.SelectSingleNode("service");
                    string service = serviceNode != null ? GetAttributeValue(serviceNode, "name") : "none";

                    PDF.WriteLine($"protocol: ", true, PDF.boldFont);
                    PDF.Write(protocol);
                    PDF.Write($"id: ", false, PDF.boldFont, XBrushes.Black, 90);
                    PDF.Write(portid);

                    if (state == "open") { stateColor = XBrushes.Red; }
                    else if (state == "closed") { stateColor = XBrushes.Green; }
                    else { stateColor = XBrushes.Black; }

                    PDF.Write($"state: ", false, PDF.boldFont, XBrushes.Black, 160);
                    PDF.Write(state, false, PDF.normalFont, stateColor);
                    PDF.Write($"service: ", false, PDF.boldFont, XBrushes.Black, 240);
                    PDF.Write(service);
                }
            }
        }

        private static void WriteOS()
        {
            XmlNodeList osmatchNodes = xml.GetElementsByTagName("osmatch");

            if (osmatchNodes.Count > 0)
            {
                PDF.WriteTitle("OS Match: ");

                foreach (XmlNode node in osmatchNodes)
                {
                    string name = GetAttributeValue(node, "name");
                    string accuracy = GetAttributeValue(node, "accuracy");

                    PDF.WriteLine($"{name} ", true);
                    PDF.Write("| ", false, PDF.boldFont, XBrushes.Purple);
                    PDF.Write($"accuracy: {accuracy}%");
                }
            }
        }

        private static void WritePortsOS()
        {
            XmlNodeList portNodes = xml.GetElementsByTagName("portused");
            XBrush stateColor;

            if (portNodes.Count > 0)
            {
                PDF.WriteTitle("OS Ports: ");

                foreach (XmlNode node in portNodes)
                {
                    string protocol = GetAttributeValue(node, "proto");
                    string portid = GetAttributeValue(node, "portid");
                    string state = GetAttributeValue(node, "state");

                    PDF.WriteLine($"protocol: ", true, PDF.boldFont);
                    PDF.Write(protocol);
                    PDF.Write($"id: ", false, PDF.boldFont, XBrushes.Black, 90);
                    PDF.Write(portid);

                    if (state == "open") { stateColor = XBrushes.Red; }
                    else if (state == "closed") { stateColor = XBrushes.Green; }
                    else { stateColor = XBrushes.Black; }

                    PDF.Write($"state: ", false, PDF.boldFont, XBrushes.Black, 160);
                    PDF.Write(state, false, PDF.normalFont, stateColor);
                }
            }
        }

        private static void WriteAllNodes(XmlNode node, double indent = 0)
        {
            double indentStep = 15;

            PDF.WriteLine($"{node.Name}: {node.Value}",
                true, PDF.normalFont, XBrushes.Black, indent);

            if (node.Attributes != null)
            {
                foreach (XmlAttribute attribute in node.Attributes)
                {
                    PDF.WriteLine($"{attribute.Name}: {attribute.Value}",
                        true, PDF.normalFont, XBrushes.Black, indent + indentStep);
                }
            }

            foreach (XmlNode childNode in node.ChildNodes)
            {
                WriteAllNodes(childNode, indent + indentStep);
            }
        }

        private static void WriteAll()
        {
            if (xml.DocumentElement != null)
            {
                PDF.NewPage();
                WriteAllNodes(xml.DocumentElement);
            }
        }

        private static string GetAttributeValue(string nodeName, string attributeName)
        {
            string value = "not found";

            XmlNode? node = xml.SelectSingleNode($"//{nodeName}");
            if (node != null)
            {
                value = GetAttributeValue(node, attributeName);
            }
            return value;
        }

        private static string GetAttributeValue(XmlNode node, string attributeName)
        {
            string value = "not found";

            XmlAttributeCollection? collection = node.Attributes;
            if (collection != null)
            {
                XmlAttribute? attribute = collection[attributeName];
                if (attribute != null)
                {
                    value = attribute.Value;
                }
            }
            return value;
        }
    }
}