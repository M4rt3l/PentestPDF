using PdfSharp.Drawing;
using System.Text.RegularExpressions;

namespace PentestPDF
{
    public static class Mimikatz
    {
        public static void WriteTxt(string txtPath)
        {
            // Writing Header
            Creator.WriteLine("Mimikatz scan report",
                false,
                new XFont("Arial", 20, XFontStyle.Bold),
                XBrushes.Blue);
            Creator.WriteLine($"Created: {DateTime.Now:dd.MM.yyyy HH:mm:ss}",
                false,
                new XFont("Arial", 12, XFontStyle.Regular),
                XBrushes.Black);
            Creator.WriteSeparator();

            if (txtPath != null )
            {
                List<Element> records = ReadTxt(txtPath);
                List<Element> reducedRecords = ReduceRecord(records);
                WriteAll(reducedRecords);
            }
        }

        private static void WriteAll(List<Element> records)
        {
            int lineCount;
            int recordHeight;

            foreach (Element record in records)
            {
                lineCount = CalculateDescendantCount(record);
                recordHeight = Creator.normalFont.Height * lineCount;

                if (Creator.posY + recordHeight > Creator.page.Height - Creator.padding)
                {
                    Creator.NewPage();
                }

                foreach (Element eL1 in record.Children)
                {
                    Creator.WriteLine($"{eL1.Name}: {eL1.Value}", false);

                    foreach (Element eL2 in eL1.Children)
                    {
                        Creator.WriteLine($"{eL2.Name}: {eL2.Value}",
                            true, Creator.normalFont, XBrushes.Black, 5,
                            Creator.padding + 10);

                        foreach (Element eL3 in eL2.Children)
                        {
                            Creator.WriteLine($"{eL3.Name}: {eL3.Value}",
                                true, Creator.normalFont, XBrushes.Black, 5,
                                Creator.padding + 30);
                        }
                    }
                }
                Creator.WriteSeparator();
            }
        }

        private static List<Element> ReduceRecord(List<Element> records)
        {
            List<Element> modRecords = new List<Element>();
            Element modR = new Element();
            Element modL1 = new Element();
            Element modL2 = new Element();
            Element modL3 = new Element();

            foreach (Element R in records)
            {
                bool hasNullDomain = R.Children.Any(child =>
                child.Name == "Domain" && child.Value == "(null)");

                if (hasNullDomain) break;

                foreach (Element L1 in R.Children)
                {
                    string[] required = { "User Name", "Domain", "SID" };
                    bool filter = required.Contains(L1.Name);

                    if (filter)
                    {
                        modL1 = new Element(L1.Name, L1.Value);

                        foreach (Element L2 in L1.Children)
                        {
                            bool hasValue = !(L2.Value == "" || L2.Value == "(null)");
                            bool hasNullChild = L2.Children.Any(child => child.Value == "(null)");
                            bool hasChildren = L2.Children.Count > 0;

                            if ((hasValue || hasChildren) && !hasNullChild)
                            {
                                modL2 = new Element(L2.Name, L2.Value);

                                foreach (Element L3 in L2.Children)
                                {
                                    string[] excluded = { "Username", "Domain" };
                                    bool filter2 = excluded.Contains(L3.Name);
                                    if (!filter2)
                                    {
                                        modL3 = new Element(L3.Name, L3.Value);
                                        modL2.AddChild(modL3);
                                    }
                                }
                                modL1.AddChild(modL2);
                            }
                        }
                        modR.AddChild(modL1);
                    }
                }
                modRecords.Add(modR);
                modR = new Element();
            }
            return modRecords;
        }

        private static List<Element> ReadTxt(string txtPath)
        {
            string[] lines = File.ReadAllLines(txtPath);

            const string patternL1 = @"^((?:\w+\s)*\w+)\s*:\s*(.*)"; //multiple words : anything
            const string patternL2 = @"^\s*(\w+)\s*:\s*(.*)";        // word : anything
            const string patternL3 = @"^\s*\*\s*(\w+)\s*:\s*(.*)";   // * word : anything

            List<Element> Records = new List<Element>();
            Element activeRecord = new Element();
            Element activeL1 = new Element();
            Element activeL2 = new Element();
            Element activeL3;

            bool spaceEnabled = false;

            foreach (string line in lines)
            {
                Match matchS = Regex.Match(line, @"^\s*$");
                Match matchL1 = Regex.Match(line, patternL1);
                Match matchL2 = Regex.Match(line, patternL2);
                Match matchL3 = Regex.Match(line, patternL3);

                if (matchL1.Success)
                {
                    activeL1 = new Element(matchL1.Groups[1].Value, matchL1.Groups[2].Value);
                    activeRecord.AddChild(activeL1);
                    spaceEnabled = true;
                }
                else if (matchL2.Success)
                {
                    activeL2 = new Element(matchL2.Groups[1].Value, matchL2.Groups[2].Value);
                    activeL1.AddChild(activeL2);
                }
                else if (matchL3.Success)
                {
                    activeL3 = new Element(matchL3.Groups[1].Value, matchL3.Groups[2].Value);
                    activeL2.AddChild(activeL3);
                }
                else if (matchS.Success && spaceEnabled)
                {
                    Records.Add(activeRecord);
                    activeRecord = new Element();
                }
            }
            return Records;
        }

        private static int CalculateDescendantCount(Element element)
        {
            int descendantCount = 0;
            foreach (Element child in element.Children)
            {
                descendantCount++;
                descendantCount += CalculateDescendantCount(child);
            }
            return descendantCount;
        }
    }
}