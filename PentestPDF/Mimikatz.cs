using PdfSharp.Drawing;
using System.Text.RegularExpressions;

namespace PentestPDF
{
    public static class Mimikatz
    {
        public static void WriteTxt(string txtPath)
        {
            // Writing Header
            Creator.WriteLine("Mimikatz scan report",
                false,
                new XFont("Arial", 20, XFontStyle.Bold),
                XBrushes.Blue);
            Creator.WriteLine($"Created: {DateTime.Now:dd.MM.yyyy HH:mm:ss}",
                false,
                new XFont("Arial", 12, XFontStyle.Regular),
                XBrushes.Black);
            Creator.WriteSeparator();

            if (txtPath != null )
            {
                List<Element> Records = ReadTxt(txtPath);
                WriteLess(Records);
                //WriteAll(Records);
            }
        }

        public static void WriteLess(List<Element> Records)
        {
            foreach (Element record in Records)
            {
                bool hasNullDomain = record.Children.Any(child =>
                child.Name == "Domain" && child.Value == "(null)");

                if (hasNullDomain) break;

                foreach (Element eL1 in record.Children)
                {
                    string[] required = { "User Name", "Domain", "SID" };
                    bool filter = required.Contains(eL1.Name);

                    if (filter)
                    {
                        Creator.WriteLine($"{eL1.Name}: {eL1.Value}", false);

                        foreach (Element eL2 in eL1.Children)
                        {
                            bool hasValue = !(eL2.Value == "" || eL2.Value == "(null)");
                            bool hasNullChild = eL2.Children.Any(child => child.Value == "(null)");
                            bool hasChildren = eL2.Children.Count > 0;

                            if ((hasValue || hasChildren) && !hasNullChild)
                            {
                                Creator.WriteLine($"{eL2.Name}: {eL2.Value}",
                                    true, Creator.normalFont, XBrushes.Black, 5,
                                    Creator.padding + 10);

                                foreach (Element eL3 in eL2.Children)
                                {
                                    string[] excluded = { "Username", "Domain" };
                                    bool filter2 = excluded.Contains(eL3.Name);
                                    if (!filter2)
                                    {
                                        Creator.WriteLine($"{eL3.Name}: {eL3.Value}",
                                            true, Creator.normalFont, XBrushes.Black, 5,
                                            Creator.padding + 30);
                                    }
                                }
                            }
                        }
                    }
                }
                Creator.WriteSeparator();
            }
        }

        public static void WriteAll(List<Element> Records)
        {
            foreach (Element record in Records)
            {
                foreach (Element eL1 in record.Children)
                {
                    Creator.WriteLine($"{eL1.Name}: {eL1.Value}", false);

                    foreach (Element eL2 in eL1.Children)
                    {
                        Creator.WriteLine($"{eL2.Name}: {eL2.Value}",
                            true, Creator.normalFont, XBrushes.Black, 5,
                            Creator.padding + 10);

                        foreach (Element eL3 in eL2.Children)
                        {
                            Creator.WriteLine($"{eL3.Name}: {eL3.Value}",
                                true, Creator.normalFont, XBrushes.Black, 5,
                                Creator.padding + 30);
                        }
                    }
                }
                Creator.WriteSeparator();
            }
        }

        public static List<Element> ReadTxt(string txtPath)
        {
            string[] lines = File.ReadAllLines(txtPath);

            const string patternL1 = @"^((?:\w+\s)*\w+)\s*:\s*(.*)"; //multiple words : anything
            const string patternL2 = @"^\s*(\w+)\s*:\s*(.*)";        // word : anything
            const string patternL3 = @"^\s*\*\s*(\w+)\s*:\s*(.*)";   // * word : anything

            List<Element> Records = new List<Element>();
            Element activeRecord = new Element();
            Element activeL1 = new Element();
            Element activeL2 = new Element();
            Element activeL3;

            bool spaceEnabled = false;


            foreach (string line in lines)
            {
                Match matchS = Regex.Match(line, @"^\s*$");
                Match matchL1 = Regex.Match(line, patternL1);
                Match matchL2 = Regex.Match(line, patternL2);
                Match matchL3 = Regex.Match(line, patternL3);

                if (matchL1.Success) // Level 1
                {
                    activeL1 = new Element(matchL1.Groups[1].Value, matchL1.Groups[2].Value);
                    activeRecord.Children.Add(activeL1);
                    spaceEnabled = true;
                }
                else if (matchL2.Success) // Level 2
                {
                    activeL2 = new Element(matchL2.Groups[1].Value, matchL2.Groups[2].Value);
                    activeL1.Children.Add(activeL2);
                }
                else if (matchL3.Success) // Level 3
                {
                    activeL3 = new Element(matchL3.Groups[1].Value, matchL3.Groups[2].Value);
                    activeL2.Children.Add(activeL3);
                }
                else if (matchS.Success && spaceEnabled) // Main Elemlent
                {
                    Records.Add(activeRecord);
                    activeRecord = new Element();
                }
            }
            return Records;
        }

    }

    public class Element
    {
        public string Name { get; set; }
        public string Value { get; set; }
        public List<Element> Children { get; set; }

        public Element(string name = "", string value = "")
        {
            Name = name;
            Value = value;
            Children = new List<Element>();
        }
    }
}