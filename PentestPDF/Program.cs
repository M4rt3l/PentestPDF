using PdfSharp.Drawing;
using PdfSharp.Pdf;
using System.Diagnostics;
using System.Xml;

public class Program
{
    private static PdfDocument document = new PdfDocument();
    private static PdfPage page = document.AddPage();
    private static XGraphics gfx = XGraphics.FromPdfPage(page);
    private static XmlDocument xml = new XmlDocument();
    private static XFont normalFont = new XFont("Arial", 10, XFontStyle.Regular);
    private static double posY = 70;
    private static double padding = 70;

    public static void Main()
    {
        System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);

        string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
        string xmlName = "nmap_13-03-2024_17-15";
        string xmlPath = Path.Combine(desktopPath, $"Pentest Reports\\{xmlName}.xml");
        string outputPath = Path.Combine(desktopPath, $"Pentest Reports\\{xmlName}.pdf");

        // Writing Header
        WriteLine("NMAP scan report", 
            false,
            new XFont("Arial", 20, XFontStyle.Bold),
            XBrushes.Red);
        WriteLine($"Created: {DateTime.Now:dd.MM.yyyy HH:mm:ss}",
            false,
            new XFont("Arial", 12, XFontStyle.Regular),
            XBrushes.Black);
        WriteSeparator();

        // Writing XML
        if (xmlPath != null)
        {
            xml.Load(xmlPath);

            WriteLine("Nmap:", false, new XFont("Arial", 12, XFontStyle.Bold), XBrushes.Black, 10);
            WriteAttribute("nmaprun", "version");
            WriteAttribute("nmaprun", "args");
            WriteAttribute("runstats/finished", "elapsed");
            WriteAttribute("runstats/finished", "exit", "state");

            // Writing ports
            WriteLine("Ports:", false, new XFont("Arial", 12, XFontStyle.Bold), XBrushes.Black, 10);
            WritePorts();

            // Writing OS
            WriteLine("OS Match:", false, new XFont("Arial", 12, XFontStyle.Bold), XBrushes.Black, 10);
            WriteOS();

            WriteLine("OS Ports:", false, new XFont("Arial", 12, XFontStyle.Bold), XBrushes.Black, 10);
            WritePortsOS();

            // Writing all
            if (xml.DocumentElement != null)
            {
                NewPage();
                WriteAllNodes(xml.DocumentElement, 0);
            }
        }

        // Saving
        document.Save(outputPath);
        document.Close();
        OpenFile(outputPath);
    }

    public static void WritePorts()
    {
        XmlNodeList portNodes = xml.GetElementsByTagName("port");

        foreach (XmlNode node in portNodes)
        {
            string protocol = GetAttributeValue(node, "protocol");
            string portid = GetAttributeValue(node, "portid");

            XmlNode? stateNode = node.SelectSingleNode("state");
            string state = stateNode != null ? GetAttributeValue(stateNode, "state") : "none";

            XmlNode? serviceNode = node.SelectSingleNode("service");
            string service = serviceNode != null ? GetAttributeValue(serviceNode, "name") : "none";

            //WriteLine($"protocol: {protocol}, id: {portid}, state: {state}, service: {service}");
            WriteLine($"protocol: {protocol}");
            Write($"id: {portid}", padding + 90);
            Write($"state: {state}", padding + 160);
            Write($"service: {service}", padding + 240);
        }
    }

    public static void WriteOS()
    {
        XmlNodeList osmatchNodes = xml.GetElementsByTagName("osmatch");

        foreach (XmlNode node in osmatchNodes)
        {
            string name = GetAttributeValue(node, "name");
            string accuracy = GetAttributeValue(node, "accuracy");

            WriteLine($"{name} (accuracy: {accuracy}%)");
        }
    }

    public static void WritePortsOS()
    {
        XmlNodeList portNodes = xml.GetElementsByTagName("portused");

        foreach (XmlNode node in portNodes)
        {
            string protocol = GetAttributeValue(node, "proto");
            string portid = GetAttributeValue(node, "portid");
            string state = GetAttributeValue(node, "state");

            //WriteLine($"protocol: {protocol}, id: {portid}, state: {state}");
            WriteLine($"protocol: {protocol}");
            Write($"id: {portid}", padding + 90);
            Write($"state: {state}", padding + 160);
        }
    }

    public static void WriteAllNodes(XmlNode node, double indent)
    {
        double indentStep = 10;

        WriteLine($"{node.Name}: {node.Value}", 
            true, normalFont, XBrushes.Black, 5,
            padding + indent);

        if (node.Attributes != null)
        {
            foreach (XmlAttribute attribute in node.Attributes)
            {
                WriteLine($"{attribute.Name}: {attribute.Value}", 
                    true, normalFont, XBrushes.Black, 5,
                    padding + indent + indentStep);
            }
        }

        // Display child nodes recursively
        foreach (XmlNode childNode in node.ChildNodes)
        {
            WriteAllNodes(childNode, indent + indentStep);
        }
    }

    public static void WriteAttribute(string elementName, string attributeName, string newName = "")
    {
        XmlNode? elementNode = xml.SelectSingleNode($"//{elementName}");
        if (elementNode != null)
        {
            string attributeValue = GetAttributeValue(elementNode, attributeName);
            string name = newName != "" ? newName : attributeName;
            WriteLine($"{name}: {attributeValue}");
        }
    }

    public static string GetAttributeValue(XmlNode node, string name)
    {
        string value = "not found";

        if (node != null)
        {
            XmlAttributeCollection? collection = node.Attributes;
            if (collection != null)
            {
                XmlAttribute? attribute = collection[name];
                if (attribute != null)
                {
                    value = attribute.Value;
                }
            }
        }

        return value;
    }

    public static void Write(string text, double posX = 0, XFont? font = null, XBrush? brush = null)
    {
        font = font == null ? normalFont : font;
        brush = brush == null ? XBrushes.Black : brush;
        gfx.DrawString(text, font, brush, new XPoint(posX, posY));
    }

    public static void WriteLine(string text, bool bullet = true, XFont? font = null, XBrush? brush = null, int lineSpace = 5, double posX = 0)
    {
        posX = posX == 0 ? padding : posX;
        font = font == null ? normalFont : font;
        brush = brush == null ? XBrushes.Black : brush;

        if (posY > page.Height - padding)
        {
            NewPage();
        }

        double charWidth;
        double stringWidth = 0;
        double lineWidth = page.Width - posX - padding;
        double lineHeight = font.GetHeight();
        posY += lineHeight + lineSpace; // newline

        if (bullet)
        {
            gfx.DrawString($"\u2022", font, brush, new XPoint(posX, posY));
            posX += 10; // space for bullet
        }

        foreach (char character in text)
        {
            if (stringWidth >= lineWidth)
            {
                if (posY > page.Height - padding)
                {
                    NewPage();
                }

                posY += lineHeight + lineSpace; // newline
                stringWidth = 0;
            }

            gfx.DrawString(character.ToString(), font, brush,
                new XPoint(posX + stringWidth, posY));

            charWidth = gfx.MeasureString(character.ToString(), font).Width;
            stringWidth += charWidth;
        }
    }

    public static void WriteSeparator()
    {
        posY += 5;
        gfx.DrawLine(new XPen(XColors.Black, 0.5),
            new XPoint(padding, posY),
            new XPoint(page.Width - padding, posY));
    }

    public static void NewPage()
    {
        page = new PdfPage();
        document.AddPage(page);
        gfx.Dispose();
        gfx = XGraphics.FromPdfPage(page);
        posY = padding; //reset
    }

    public static void OpenFile(string path)
    {
        if (File.Exists(path))
        {
            Process.Start("explorer.exe", path);
        }
    }
}
