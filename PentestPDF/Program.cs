using PdfSharp.Drawing;
using PdfSharp.Pdf;
using System.Diagnostics;
using System.Xml;

public class Program
{
    private static PdfDocument document = new PdfDocument();
    private static PdfPage page = document.AddPage();
    private static XmlDocument xml = new XmlDocument();
    private static XFont normalFont = new XFont("Arial", 10, XFontStyle.Regular);
    private static double posY = 70;
    private static double padding = 70;

    public static void Main()
    {
        System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);

        string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
        string xmlPath = Path.Combine(desktopPath, "Pentest Reports\\output.xml");
        string outputPath = Path.Combine(desktopPath, "Pentest Reports\\output.pdf");

        // Writing Header
        WriteLine("NMAP scan report", 
            false,
            new XFont("Arial", 20, XFontStyle.Bold),
            XBrushes.Red);
        WriteLine($"Created: {DateTime.Now:dd.MM.yyyy HH:mm:ss}",
            false,
            new XFont("Arial", 14, XFontStyle.Regular),
            XBrushes.Black);
        WriteSeparator();

        // Writing XML
        if (xmlPath != null)
        {
            xml.Load(xmlPath);

            WriteLine("Nmap:", false, new XFont("Arial", 12, XFontStyle.Bold), XBrushes.Black, 10);
            WriteAttribute("nmaprun", "version");
            WriteAttribute("nmaprun", "args");
            WriteAttribute("runstats/finished", "elapsed");
            WriteAttribute("runstats/finished", "exit", "state");

            // Writing ports
            WriteLine("Ports:", false, new XFont("Arial", 12, XFontStyle.Bold), XBrushes.Black, 10);
            WritePorts();

            // Writing OS
            WriteLine("OS Match:", false, new XFont("Arial", 12, XFontStyle.Bold), XBrushes.Black, 10);
            WriteAttribute("osclass", "vendor");
            WriteAttribute("osclass", "osfamily");
            WriteAttribute("osclass", "osgen");
            WriteAttribute("osclass", "accuracy");

            WriteLine("OS Ports:", false, new XFont("Arial", 12, XFontStyle.Bold), XBrushes.Black, 10);
            WritePortsOS();

            // Writing all
            if (xml.DocumentElement != null)
            {
                NewPage();
                WriteAllNodes(xml.DocumentElement, 0);
            }
        }

        // Saving
        document.Save(outputPath);
        document.Close();
        OpenFile(outputPath);
    }

    public static void WritePorts()
    {
        XmlNodeList portNodes = xml.GetElementsByTagName("port");

        foreach (XmlNode portNode in portNodes)
        {
            string protocol = GetAttributeValue(portNode, "protocol");
            string portid = GetAttributeValue(portNode, "portid");

            XmlNode? stateNode = portNode.SelectSingleNode("state");
            string state = stateNode != null ? GetAttributeValue(stateNode, "state") : "none";

            XmlNode? serviceNode = portNode.SelectSingleNode("service");
            string service = serviceNode != null ? GetAttributeValue(serviceNode, "name") : "none";

            //WriteLine($"protocol: {protocol}, id: {portid}, state: {state}, service: {service}");
            WriteLine($"protocol: {protocol}");
            Write($"id: {portid}", padding + 90);
            Write($"state: {state}", padding + 160);
            Write($"service: {service}", padding + 240);
        }
    }

    public static void WritePortsOS()
    {
        XmlNodeList portNodes = xml.GetElementsByTagName("portused");

        foreach (XmlNode portNode in portNodes)
        {
            string protocol = GetAttributeValue(portNode, "proto");
            string portid = GetAttributeValue(portNode, "portid");
            string state = GetAttributeValue(portNode, "state");

            //WriteLine($"protocol: {protocol}, id: {portid}, state: {state}");
            WriteLine($"protocol: {protocol}");
            Write($"id: {portid}", padding + 90);
            Write($"state: {state}", padding + 160);
        }
    }

    public static void WriteAllNodes(XmlNode node, double indent)
    {
        double indentStep = 10;

        WriteLine($"{node.Name}: {node.Value}", 
            true, normalFont, XBrushes.Black, 5,
            padding + indent);

        if (node.Attributes != null)
        {
            foreach (XmlAttribute attribute in node.Attributes)
            {
                WriteLine($"{attribute.Name}: {attribute.Value}", 
                    true, normalFont, XBrushes.Black, 5,
                    padding + indent + indentStep);
            }
        }

        // Display child nodes recursively
        foreach (XmlNode childNode in node.ChildNodes)
        {
            WriteAllNodes(childNode, indent + indentStep);
        }
    }

    public static void WriteAttribute(string elementName, string attributeName, string newName = "")
    {
        XmlNode? elementNode = xml.SelectSingleNode($"//{elementName}");
        if (elementNode != null)
        {
            string attributeValue = GetAttributeValue(elementNode, attributeName);
            string name = newName != "" ? newName : attributeName;
            WriteLine($"{name}: {attributeValue}");
        }
    }

    public static string GetAttributeValue(XmlNode node, string name)
    {
        string value = "not found";

        if (node != null)
        {
            XmlAttributeCollection? collection = node.Attributes;
            if (collection != null)
            {
                XmlAttribute? attribute = collection[name];
                if (attribute != null)
                {
                    value = attribute.Value;
                }
            }
        }

        return value;
    }

    public static void WriteLine(string text, bool bullet = true, XFont? font = null, XBrush? brush = null, int lineSpace = 5, double posX = 0)
    {
        if (posY > page.Height - padding)
        {
            NewPage();
        }

        posX = posX == 0 ? padding : posX;
        font = font == null ? normalFont : font;
        brush = brush == null ? XBrushes.Black : brush;

        double lineHeight = font.GetHeight();
        posY += lineHeight + lineSpace;

        using (XGraphics gfx = XGraphics.FromPdfPage(page))
        {
            if (bullet)
            {
                gfx.DrawString($"\u2022", font, brush, new XPoint(posX, posY));
                gfx.DrawString($"{text}", font, brush, new XPoint(posX + 10, posY));
            }
            else
            {
                gfx.DrawString($"{text}", font, brush, new XPoint(posX, posY));
            }
        }
    }

    public static void Write(string text, double posX = 0, XFont? font = null, XBrush? brush = null)
    {
        posX = posX == 0 ? padding : posX;
        font = font == null ? normalFont : font;
        brush = brush == null ? XBrushes.Black : brush;

        using (XGraphics gfx = XGraphics.FromPdfPage(page))
        {
            gfx.DrawString($"{text}", font, brush, new XPoint(posX, posY));
        }
    }

    public static void WriteSeparator()
    {
        using (XGraphics gfx = XGraphics.FromPdfPage(page))
        {
            posY += 5;
            gfx.DrawLine(new XPen(XColors.Black, 0.5),
                new XPoint(padding, posY),
                new XPoint(page.Width - padding, posY));
        }
    }

    public static void NewPage()
    {
        page = new PdfPage();
        document.AddPage(page);
        posY = padding; //reset
    }

    public static void OpenFile(string path)
    {
        if (File.Exists(path))
        {
            Process.Start("explorer.exe", path);
        }
    }
}
