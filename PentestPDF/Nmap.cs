using PdfSharp.Drawing;
using System.Text.RegularExpressions;
using System.Xml;

namespace PentestPDF
{
    public static class Nmap
    {
        private static readonly XmlDocument xml = new();

        public static void WriteXml(string xmlPath)
        {
            // Writing Header
            Creator.Write("NMAP scan report", false,
                new XFont("Arial", 20, XFontStyle.Bold),
                XBrushes.Red);
            Creator.WriteLine($"Created: {DateTime.Now:dd.MM.yyyy HH:mm:ss}",
                false,
                new XFont("Arial", 12, XFontStyle.Regular),
                XBrushes.Black);
            Creator.WriteSeparator(5);

            // Writing XML
            if (xmlPath != null)
            {
                xml.Load(xmlPath);
                WriteRunInfo();
                WritePorts();
                WriteOS();
                WritePortsOS();
            }
        }

        private static void WriteRunInfo()
        {
            string version = GetAttributeValue("nmaprun", "version");
            string args = GetAttributeValue("nmaprun", "args");
            string elapsed = GetAttributeValue("runstats/finished", "elapsed");
            string exit = GetAttributeValue("runstats/finished", "exit");

            XBrush color;
            if (exit == "success") { color = XBrushes.Green; }
            else { color = XBrushes.Red; }

            Creator.WriteTitle("Nmap");
            Creator.WriteLine("Version: ", true, Creator.boldFont);
            Creator.Write(version);
            args = args.Replace("\\\\", "\\");
            args = ParseArgs(args);
            Creator.WriteLine("Args: ", true, Creator.boldFont);
            Creator.WriteLine(args, false, Creator.normalFont, XBrushes.Black, 15);
            Creator.WriteLine("Elapsed: ", true, Creator.boldFont);
            Creator.Write($"{elapsed} s");
            Creator.WriteLine("Exit: ", true, Creator.boldFont);
            Creator.Write(exit, false, Creator.normalFont, color);
        }

        private static string ParseArgs(string args)
        {
            // [^\"]+ : one or more characters that are not a quotation mark
            string pattern = "\"([^\"]+)\"\\s*(.*)";
            Match match = Regex.Match(args, pattern);
            if (match.Success)
            {
                string path = match.Groups[1].Value;
                args = $"nmap {match.Groups[2].Value}";
                Creator.WriteLine("Path: ", true, Creator.boldFont);
                Creator.Write(path);
            }
            return args;
        }

        private static void WritePorts()
        {
            XmlNodeList portNodes = xml.GetElementsByTagName("port");
            XBrush stateColor;

            Creator.WriteTitle("Ports");

            foreach (XmlNode node in portNodes)
            {
                string protocol = GetAttributeValue(node, "protocol");
                string portid = GetAttributeValue(node, "portid");

                XmlNode? stateNode = node.SelectSingleNode("state");
                string state = stateNode != null ? GetAttributeValue(stateNode, "state") : "none";

                XmlNode? serviceNode = node.SelectSingleNode("service");
                string service = serviceNode != null ? GetAttributeValue(serviceNode, "name") : "none";

                Creator.WriteLine($"protocol: ", true, Creator.boldFont);
                Creator.Write(protocol);
                Creator.Write($"id: ", false, Creator.boldFont, XBrushes.Black, 90);
                Creator.Write(portid);

                if (state == "open") { stateColor = XBrushes.Red; }
                else if (state == "closed") { stateColor = XBrushes.Green; }
                else { stateColor = XBrushes.Black; }

                Creator.Write($"state: ", false, Creator.boldFont, XBrushes.Black, 160);
                Creator.Write(state, false, Creator.normalFont, stateColor);
                Creator.Write($"service: ", false, Creator.boldFont, XBrushes.Black, 240);
                Creator.Write(service);
            }
        }

        private static void WriteOS()
        {
            XmlNodeList osmatchNodes = xml.GetElementsByTagName("osmatch");

            Creator.WriteTitle("OS Match");

            foreach (XmlNode node in osmatchNodes)
            {
                string name = GetAttributeValue(node, "name");
                string accuracy = GetAttributeValue(node, "accuracy");

                Creator.WriteLine($"{name} ", true);
                Creator.Write("| ", false, Creator.boldFont, XBrushes.Purple);
                Creator.Write($"accuracy: {accuracy}%");
            }
        }

        private static void WritePortsOS()
        {
            XmlNodeList portNodes = xml.GetElementsByTagName("portused");
            XBrush stateColor = XBrushes.Black;

            Creator.WriteTitle("OS Ports");

            foreach (XmlNode node in portNodes)
            {
                string protocol = GetAttributeValue(node, "proto");
                string portid = GetAttributeValue(node, "portid");
                string state = GetAttributeValue(node, "state");

                Creator.WriteLine($"protocol: ", true, Creator.boldFont);
                Creator.Write(protocol);
                Creator.Write($"id: ", false, Creator.boldFont, XBrushes.Black, 90);
                Creator.Write(portid);

                if (state == "open") { stateColor = XBrushes.Red; }
                else if (state == "closed") { stateColor = XBrushes.Green; }
                else { stateColor = XBrushes.Black; }

                Creator.Write($"state: ", false, Creator.boldFont, XBrushes.Black, 160);
                Creator.Write(state, false, Creator.normalFont, stateColor);
            }
        }

        private static void WriteAllNodes(XmlNode node, double indent = 0)
        {
            double indentStep = 15;

            Creator.WriteLine($"{node.Name}: {node.Value}",
                true, Creator.normalFont, XBrushes.Black, 
                Creator.padding + indent);

            if (node.Attributes != null)
            {
                foreach (XmlAttribute attribute in node.Attributes)
                {
                    Creator.WriteLine($"{attribute.Name}: {attribute.Value}",
                        true, Creator.normalFont, XBrushes.Black, 
                        Creator.padding + indent + indentStep);
                }
            }

            foreach (XmlNode childNode in node.ChildNodes)
            {
                WriteAllNodes(childNode, indent + indentStep);
            }
        }

        private static void WriteAll()
        {
            if (xml.DocumentElement != null)
            {
                Creator.NewPage();
                WriteAllNodes(xml.DocumentElement);
            }
        }

        private static string GetAttributeValue(string nodeName, string attributeName)
        {
            string value = "not found";

            XmlNode? node = xml.SelectSingleNode($"//{nodeName}");
            if (node != null)
            {
                value = GetAttributeValue(node, attributeName);
            }
            return value;
        }

        private static string GetAttributeValue(XmlNode node, string attributeName)
        {
            string value = "not found";

            XmlAttributeCollection? collection = node.Attributes;
            if (collection != null)
            {
                XmlAttribute? attribute = collection[attributeName];
                if (attribute != null)
                {
                    value = attribute.Value;
                }
            }
            return value;
        }
    }
}