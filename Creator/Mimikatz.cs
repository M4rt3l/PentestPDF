using PdfSharp.Drawing;
using System.Text.RegularExpressions;

namespace Creator
{
    public static class Mimikatz
    {
        static List<string> commands = new();
        static string version = "";

        public static void WriteTxt(string txtPath)
        {
            //Creator.champter = "Mimikatz scan report";
            Creator.NewPage();

            Creator.WriteLine("Mimikatz scan report", false,
                new XFont("Arial", 20, XFontStyle.Bold),
                XBrushes.Red);
            Creator.WriteLine($"Created: {DateTime.Now:dd.MM.yyyy HH:mm:ss}", false,
                new XFont("Arial", 12, XFontStyle.Regular),
                XBrushes.Black);
            Creator.WriteSeparator(5);

            if (txtPath != null )
            {
                List<Element> records = ReadTxt(txtPath);
                List<Element> reducedRecords = ReduceRecord(records);
                WriteRunInfo();
                WriteRecords(reducedRecords);
            }
        }

        private static void WriteRunInfo()
        {
            Creator.WriteTitle("Mimikatz");
            Creator.WriteLine("Version: ", true, Creator.boldFont);
            Creator.Write(version);
            Creator.WriteLine("Commands: ", true, Creator.boldFont);
            foreach (string command in commands)
            {
                Creator.WriteLine(command, false, Creator.normalFont, XBrushes.Black, 15);
            }
        }

        private static void WriteRecords(List<Element> records)
        {
            int lineCount;
            double recordHeight;

            Creator.WriteTitle("Records");

            for (int i = 1; i<records.Count(); i++)
            {
                Element record = records[i];
                lineCount = CalculateDescendantCount(record);
                recordHeight = Creator.normalFont.Height * 1.25 * lineCount;

                if (Creator.posY + recordHeight > Creator.page.Height - Creator.padding)
                {
                    Creator.NewPage();
                }

                Creator.WriteLine($"Record {i}:", true, Creator.boldFont, XBrushes.Navy);

                foreach (Element eL1 in record.Children)
                {
                    Creator.WriteLine($"{eL1.Name}: ", true, Creator.boldFont, XBrushes.Navy, 15);
                    Creator.Write(eL1.Value);

                    foreach (Element eL2 in eL1.Children)
                    {
                        Creator.WriteLine($"{eL2.Name}: {eL2.Value}",
                            true, Creator.normalFont, XBrushes.Black, 30);

                        foreach (Element eL3 in eL2.Children)
                        {
                            Creator.WriteLine($"{eL3.Name}: {eL3.Value}",
                                true, Creator.normalFont, XBrushes.Black, 45);
                        }
                    }
                }
                //Creator.WriteSeparator(5);
            }
        }

        private static List<Element> ReduceRecord(List<Element> records)
        {
            List<Element> modRecords = new List<Element>();
            Element modR = new Element();
            Element modL1 = new Element();
            Element modL2 = new Element();
            Element modL3 = new Element();

            foreach (Element R in records)
            {
                bool hasNullDomain = R.Children.Any(child =>
                child.Name == "Domain" && child.Value == "(null)");

                if (hasNullDomain) break;

                foreach (Element L1 in R.Children)
                {
                    string[] required = { "User Name", "Domain", "SID" };
                    bool filter = required.Contains(L1.Name);

                    if (filter)
                    {
                        modL1 = new Element(L1.Name, L1.Value);

                        foreach (Element L2 in L1.Children)
                        {
                            bool hasValue = !(L2.Value == "" || L2.Value == "(null)");
                            bool hasNullChild = L2.Children.Any(child => child.Value == "(null)");
                            bool hasChildren = L2.Children.Count > 0;

                            if ((hasValue || hasChildren) && !hasNullChild)
                            {
                                modL2 = new Element(L2.Name, L2.Value);

                                foreach (Element L3 in L2.Children)
                                {
                                    string[] excluded = { "Username", "Domain" };
                                    bool filter2 = excluded.Contains(L3.Name);
                                    if (!filter2)
                                    {
                                        modL3 = new Element(L3.Name, L3.Value);
                                        modL2.AddChild(modL3);
                                    }
                                }
                                modL1.AddChild(modL2);
                            }
                        }
                        modR.AddChild(modL1);
                    }
                }
                modRecords.Add(modR);
                modR = new Element();
            }
            return modRecords;
        }

        private static List<Element> ReadTxt(string txtPath)
        {
            string[] lines = File.ReadAllLines(txtPath);

            const string patternL1 = @"^((?:\w+\s)*\w+)\s*:\s*(.*)";        //multiple words : anything
            const string patternL2 = @"^\s*(\w+)\s*:\s*(.*)";               // word : anything
            const string patternL3 = @"^\s*\*\s*(\w+)\s*:\s*(.*)";          // * word : anything
            const string patternVersion = @"mimikatz (\d+\.\d+\.\d+)";
            const string patternCommand = @"mimikatz\(commandline\) # (.*)";

            List<Element> Records = new List<Element>();
            Element activeRecord = new Element();
            Element activeL1 = new Element();
            Element activeL2 = new Element();
            Element activeL3;

            bool spaceEnabled = false;

            foreach (string line in lines)
            {
                Match matchL1 = Regex.Match(line, patternL1);
                Match matchL2 = Regex.Match(line, patternL2);
                Match matchL3 = Regex.Match(line, patternL3);
                Match matchSpace = Regex.Match(line, @"^\s*$");
                Match matchVersion = Regex.Match(line, patternVersion);
                Match matchCommand = Regex.Match(line, patternCommand);

                if (matchL1.Success)
                {
                    activeL1 = new Element(matchL1.Groups[1].Value, matchL1.Groups[2].Value);
                    activeRecord.AddChild(activeL1);
                    spaceEnabled = true;
                }
                else if (matchL2.Success)
                {
                    activeL2 = new Element(matchL2.Groups[1].Value, matchL2.Groups[2].Value);
                    activeL1.AddChild(activeL2);
                }
                else if (matchL3.Success)
                {
                    activeL3 = new Element(matchL3.Groups[1].Value, matchL3.Groups[2].Value);
                    activeL2.AddChild(activeL3);
                }
                else if (matchSpace.Success && spaceEnabled)
                {
                    Records.Add(activeRecord);
                    activeRecord = new Element();
                }
                else if (matchVersion.Success)
                {
                    version = matchVersion.Groups[1].Value;
                }
                else if (matchCommand.Success)
                {
                    commands.Add(matchCommand.Groups[1].Value);
                }
            }
            return Records;
        }

        private static int CalculateDescendantCount(Element element)
        {
            int descendantCount = 0;
            foreach (Element child in element.Children)
            {
                descendantCount++;
                descendantCount += CalculateDescendantCount(child);
            }
            return descendantCount;
        }
    }
}