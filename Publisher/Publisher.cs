using System.Diagnostics;
using System.Xml;

namespace Publisher
{
    class Publisher
    {
        static string contentDirectory = "C:\\Users\\mmart\\Desktop\\Content";

        public static void Main()
        {
            string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);

            Console.WriteLine("Content files: ");
            string[] content = Directory.GetFiles(contentDirectory, "*", SearchOption.AllDirectories);
            foreach (string file in content)
            {
                Console.WriteLine(file);
            }

            string? projectDirectory = GetProjectDirectory("RunApp");

            if (projectDirectory != null ) 
            {
                AddContent(projectDirectory, content);
                string assemblyName = "Pentest";
                AddPublishSettings(projectDirectory, assemblyName);
                CreateExecutable(projectDirectory, desktopPath);
            }
        }

        // Finds project directory (by project name) in current solution
        private static string? GetProjectDirectory(string projectName)
        {
            string? solutionDirectory = GetSolutionDirectory();
            if (solutionDirectory != null)
            {
                string[] children = Directory.GetDirectories(solutionDirectory);

                foreach (string directory in children)
                {
                    string? projectFile = Directory.GetFiles(directory, $"{projectName}.csproj").FirstOrDefault();

                    if (projectFile != null)
                    {
                        return directory;
                    }
                }
                Console.WriteLine("Project directory not found.");
            }
            return null;
        }

        private static string? GetSolutionDirectory()
        {
            string currentDir = AppDomain.CurrentDomain.BaseDirectory;
            DirectoryInfo? dirInfo = new DirectoryInfo(currentDir);

            while (dirInfo != null)
            {
                string? solutionFile = Directory.GetFiles(dirInfo.FullName, "*.sln").FirstOrDefault();
                if (solutionFile != null)
                {
                    return dirInfo.FullName;
                }
                else
                {
                    dirInfo = dirInfo.Parent;
                }
            }
            Console.WriteLine("Solution directory not found.");
            return null;
        }

        private static void AddPublishSettings(string projectDir, string assemblyName)
        {
            string? projectFile = Directory.GetFiles(projectDir, "*.csproj").FirstOrDefault();
            if (projectFile != null)
            {
                XmlDocument document = new XmlDocument();
                document.Load(projectFile);

                XmlNode? propertyGroupNode = document.SelectSingleNode("/Project/PropertyGroup");
                if (propertyGroupNode != null)
                {
                    AddNode("AssemblyName", assemblyName, propertyGroupNode);
                    AddNode("PublishSingleFile", "true", propertyGroupNode);
                    AddNode("SelfContained", "true", propertyGroupNode);
                    AddNode("IncludeAllContentForSelfExtract", "true", propertyGroupNode);
                    AddNode("IncludeNativeLibrariesForSelfExtract", "true", propertyGroupNode);
                }

                document.Save(projectFile);
            }
        }

        private static void AddContent(string projectDir, string[] content)
        {
            string? projectFile = Directory.GetFiles(projectDir, "*.csproj").FirstOrDefault();
            if (projectFile != null)
            {
                XmlDocument document = new XmlDocument();
                document.Load(projectFile);

                XmlNode? itemGroupNode = document.SelectSingleNode("/Project/ItemGroup");
                if (itemGroupNode != null)
                {
                    // Removing old content (in reverse order to avoid modifying list while iterating over it)
                    for (int i = itemGroupNode.ChildNodes.Count - 1; i >= 0; i--)
                    {
                        XmlNode? node = itemGroupNode.ChildNodes[i];
                        if (node != null && node.Name == "Content")
                        {
                            itemGroupNode.RemoveChild(node);
                        }
                    }

                    foreach (string path in content)
                    {
                        XmlElement contentElement = document.CreateElement("Content");
                        contentElement.SetAttribute("Include", path);
                        itemGroupNode.AppendChild(contentElement);

                        AddNode("CopyToOutputDirectory", "Always", contentElement);
                        string localPath = Path.GetRelativePath(contentDirectory, path);

                        AddNode("Link", $"Content\\{localPath}", contentElement);
                    }
                }
                document.Save(projectFile);
            }
        }

        private static void AddNode(string name, string value, XmlNode parentNode)
        {
            XmlDocument? document = parentNode.OwnerDocument;
            if (document != null)
            {
                XmlNode? node = parentNode.SelectSingleNode(name);
                if (node == null)
                {
                    node = document.CreateElement(name);
                    parentNode.AppendChild(node);
                }
                node.InnerText = value;
            }
        }

        private static string CreateExecutable(string projectDirectory, string outputDirectory)
        {
            string command = $"dotnet publish -r win-x64 /p:PublishSingleFile=true /p:IncludeNativeLibrariesForSelfExtract=true --self-contained true --output {outputDirectory}";

            ProcessStartInfo psi = new ProcessStartInfo
            {
                FileName = "powershell.exe",
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = projectDirectory,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                Arguments = $"-NoProfile -ExecutionPolicy Bypass -Command \"{command}\""
            };

            Process process = new Process
            {
                StartInfo = psi
            };
            process.Start();

            string output = process.StandardOutput.ReadToEnd();
            string error = process.StandardError.ReadToEnd();

            process.WaitForExit();

            return output + "\n" + error;
        }
    }
}